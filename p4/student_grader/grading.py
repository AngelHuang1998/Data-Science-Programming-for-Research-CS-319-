"""
This version of the grader is used by students
when completing their assignments. It is very similar to the
master version used by TAs/PMs except that it makes HTTP requests to
our server to get feedback from the LLM, and it uses the metadata
file to inform grader.check about test cases to run
"""

import os
import nbformat

from student_grader.io_helpers import print_feedback_student
from grader_utils import (
    CHECK_START_FORMAT,
    ISSUES_ABOVE_MSG,
    SUCCESS_MSG,
    ABOVE_QUESTION_ERROR_PREFIX,
    NO_CODE_FOR_QID_FORMAT,
    FAILED_FIND_QID_IN_METADATA_FORMAT,
    METADATA_FILE_NAME,
    METADATA_REQUIRED_VARS_KEY,
    METADATA_REQUIRED_FUNCS_KEY,
    METADATA_ASSERTIONS_KEY,
    get_nb_path,
    load_metadata_dict,
    check_student_code_against_requirements,
    execute_code,
    suppress_output,
)


_GRADER_CHECK_STUB = "student_grader.check"


def check(q_id: str, should_get_llm_feedback: bool = False) -> bool:
    """
    Executes a series of checks on the student's Jupyter notebook to verify
    that the code for a specific question (identified by `q_id`) is correct.
    This function processes the notebook cells up to the specified check
    cell and validates the student's code against required function calls,
    variable definitions, and assertions.

    Parameters:
        q_id (str): The identifier for the question to check in the notebook, like "q1"
        should_get_llm_feedback: Does the student want help from an LLM for this question?
            They will manually change this variable value in the check cell.

    Behavior:
        1. Loads the master notebook and iterates through its cells.
        2. Identifies and processes the cells corresponding to the
           grader check for the given `q_id`.
        3. Executes the student's code and captures global variables and errors.
        4. If an exception occurs while executing the student's code, provides
           immediate feedback.
        5. Validates the student's code for required function calls, variable
           definitions, and failed assertions
        6. Provides feedback on any errors found in the student's code.

    Example:
        To check the code for question 'q1', call:
            student_grader.check("q1")

    Raises:
        FileNotFoundError: If the function cannot find the student notebook file with
            the expected name or it cannot find the assignment metadata
    """

    print(CHECK_START_FORMAT.format(q_id))
    did_check_pass = False

    # Load the student notebook
    student_nb_path = get_nb_path()
    with open(student_nb_path, "r", encoding="utf-8") as f:
        notebook = nbformat.read(f, as_version=4)
    dir_path = os.path.dirname(student_nb_path)
    project_file_name = os.path.split(student_nb_path)[-1]
    project_id = project_file_name.split(".")[0]

    # Load the assignment metadata and check that q_id is present in it
    assignment_metadata = load_metadata_dict(dir_path)
    assert q_id in assignment_metadata, FAILED_FIND_QID_IN_METADATA_FORMAT.format(
        q_id, METADATA_FILE_NAME
    )

    # Store global variables and warnings/errors occuring before curent question
    global_vars = {}
    errors_in_previous_cells = []
    warnings_in_previous_cells = []

    # Execute the cells up until grader check
    for cell in notebook.cells:

        tags = cell.metadata.get("tags", [])
        found_current_question_code = f"{q_id}-code" in tags

        if found_current_question_code:
            student_code = cell.source

            # If there are warnings or errors generated by running code in the above
            # cells, alert the student and do not execute the rest of the check.
            if warnings_in_previous_cells or errors_in_previous_cells:
                print_feedback_student(
                    warnings_in_previous_cells,
                    errors_in_previous_cells,
                    student_code,
                    project_id,
                    q_id,
                    should_get_llm_feedback,
                )
                print(ISSUES_ABOVE_MSG)
                break

            current_question_errors = []
            current_question_warnings = []

            required_functions = assignment_metadata[q_id][METADATA_REQUIRED_FUNCS_KEY]
            required_vars = assignment_metadata[q_id][METADATA_REQUIRED_VARS_KEY]
            assertions = assignment_metadata[q_id][METADATA_ASSERTIONS_KEY]
            check_student_code_against_requirements(
                student_code,
                required_functions,
                required_vars,
                assertions,
                current_question_warnings,
                current_question_errors,
                global_vars,
            )

            # If the student code has any warnings or errors, print out feedback.
            # Otherwise, print out a success message.
            if current_question_warnings or current_question_errors:
                print_feedback_student(
                    current_question_warnings,
                    current_question_errors,
                    student_code,
                    project_id,
                    q_id,
                    should_get_llm_feedback,
                )
            else:
                did_check_pass = True
                print(SUCCESS_MSG)

            # Do not continue executing any other notebook cells after
            # completing check for this q_id
            break

        # If the current cell is a valid code cell not related to the current
        # question, execute it with suppressed output so its output does not appear
        # under the grader.check cell. grader.check
        # cells are skipped in order to avoid recursively calling grader.check
        elif cell.cell_type == "code" and _GRADER_CHECK_STUB not in cell.source:
            with suppress_output():
                execute_code(
                    cell.source,
                    global_vars,
                    warnings_in_previous_cells,
                    errors_in_previous_cells,
                    ABOVE_QUESTION_ERROR_PREFIX,
                )
    if not found_current_question_code:
        print(NO_CODE_FOR_QID_FORMAT.format(q_id))

    return did_check_pass
